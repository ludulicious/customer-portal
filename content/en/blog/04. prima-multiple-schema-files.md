---
title: Multiple Prisma schema files
description: "Splitting up your prima schema files seems a very smart thing to do for maintainability. But we experienced some challenges on the way. we'll explain our working solution and what not do"
image:
  src: /images/blog/prisma/layers-cake.png
authors:
  - name: Marcel Posdijk
    to: https://x.com/marcelposdijk
    avatar:
      src: https://avatars.githubusercontent.com/u/20837346?v=4
date: 2025-10-29
badge:
  label: Customer Portal
---

## Why multiple schema's in a simple project

We are developing a sample Customer Portal application that other developer can use as a starting point for their own Customer Portal.
We want to create a few real life examples, such as service request, orders and invoices that showcases the soloutions ability.

We want to make it easy for other developers to remove the functionality they don't need.
That's why we are using [Nuxt's layer functionality](https://nuxt.com/docs/4.x/getting-started/layers) to create a separate folder for each functional area.
![computer](/images/blog/prisma/layers-cake.png){.rounded-lg height="600" width="1000"}

## Prisma schemas

We are using [Prisma](https://www.prisma.io/docs/orm/prisma-schema/overview) as our ORM. Prisma typically uses only one schema file called schema.prisma 

That looks something like this:

```prisma
// prisma.schema
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String   @db.VarChar(255)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}
```

You can generate the types and client code for this schema using the command `npx prisma generate`.
You can generate migrations using the command `npx prisma migrate dev --name <name>`

By default this will generate the files in the node_modules/@prisma, a practice that is now deprecated: you should generate the output to a folder in your project (excluding it from source control) like this:

```
// prisma.schema
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

This will generate the code in a structure like this:

```bash
prisma/
├── schema.prisma
└── generated/
    └── client/
        ├── index.js
        ├── index.d.ts
        └── ... (other generated files)
```

This works fine, and there is no additional configuration needed.

I wanted to add an additional prisma schema for my service-layer module, so I read the [Prisma documentation](https://www.prisma.io/docs/orm/prisma-schema/overview/location) and created the following structure:

```bash
prisma/
├── schema.prisma 
├── service-requests.prisma 
└── generated/
    └── client/
        ├── index.js
        ├── index.d.ts
        ├── schema.prisma
        └── ... (other generated files)
```

The: `npx prisma generate` works fine the first time, but when you run it a second time, you get messages like:

```log
ERROR: Type User already exist
ERROR: Type Organization already exists

// and many more errors like this
```

Why does this happen? It turns out that The generate commands also generates the schema.prisma file in the generated files. In that file, it combines all the schema files. Running npx prisma generate again, Causes the command to find a schema.prisma both in the prisma folder and in the generated/client folder.

Deleting the generated schema.prisma file fixes things temporaily, but another solution is needed.

## The working solution

Create your prisma schema files in the following folder structure

```bash
prisma/
├── schema/
│   ├── schema.prisma 
│   ├── better-auth.prisma
│   └── service-requests.prisma
```

Create a prisma.config.ts in the root of your project:

```typescript
// prisma.config.ts in the root folder
import type { PrismaConfig } from 'prisma'
import 'dotenv/config' // this will load the environment variables, so the DATABASE_URL is available in the schema files

export default {
  schema: 'prisma/schema' // identify the folder where the schema files are located
} satisfies PrismaConfig

```

The main schema only contains the configuration:

```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
  output   = "../generated/client" // make sure the generated files are one level up to avoid conflicts with /generated/client/prisma.schema file
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

Now, both `npx prisma generate` and `npx prisma migrate dev` work fine.

Executing these commands results in the following structure:

```bash
prisma/
├── schema/
│   ├── schema.prisma
│   ├── better-auth.prisma
│   └── service-requests.prisma
├── migrations/
│   ├── <migration-timestamp>_<name>/
│   │   └── migration.sql
│   └── ...
└── generated/
    └── client/
        ├── index.js
        ├── index.d.ts
        └── ... (other generated files)
```

## Extra

In my nuxt.config.ts, I created an alias **#db** for the generated prisma client, for easy access everywhere in the project:

```typescript
// nuxt.config.ts
import { fileURLToPath } from 'node:url'

export default defineNuxtConfig({
  ssr: false,
  alias: {
    '#db': fileURLToPath(new URL('./prisma/generated/client', import.meta.url)),
  },
  // ... all other options
})
```

You can use it in the app as follows:

```typescript
import type { User } from '#db'
```


