---
title: "Setting Up Authentication with Better Auth in a Nuxt 4 Application"
description: "Learn how to implement a complete authentication system using Better Auth with email verification, social login, role-based permissions, and custom session handling."
tags: ["authentication", "better-auth", "nuxt4", "typescript", "prisma"]
image:
  src: /images/blog/auth/main.png
authors:
  - name: Marcel Posdijk
    to: https://x.com/marcelposdijk
    avatar:
      src: https://avatars.githubusercontent.com/u/20837346?v=4
date: 2025-10-26
badge:
  label: Authentication
---

Better Auth is a modern authentication library that provides a comprehensive solution for handling user authentication, authorization, and session management. In this blog post, we'll walk through how we implemented a complete authentication system in our Nuxt 3 application using Better Auth.

![computer](/images/blog/auth/main.png){.rounded-lg height="600" width="1000"}

## Overview of Our Authentication Setup

Our authentication system includes:
- Email/password authentication with verification
- Social login (GitHub)
- Role-based access control (RBAC)
- Custom session handling
- Email notifications for verification and password reset
- Global authentication middleware
- User permission management

## 1. Database Schema with Prisma

First, let's look at our Prisma schema that defines the authentication tables:

```prisma
// prisma/schema.prisma
model User {
  id            String   @id @default(cuid())
  name          String?
  email         String   @unique
  emailVerified Boolean? @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  sessions               Session[]
  accounts               Account[]

  // Custom fields for our application
  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy String?

  @@map("sessions")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  providerId         String
  providerAccountId  String
  accessToken        String?
  refreshToken       String?
  idToken            String?
  accessTokenExpiresAt DateTime?
  refreshTokenExpiresAt DateTime?
  scope              String?
  password           String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, providerAccountId])
  @@map("accounts")
}
```

## 2. Better Auth Server Configuration

Our main authentication configuration is in `lib/auth.ts`:

```typescript
// lib/auth.ts
import { betterAuth } from 'better-auth'
import { prismaAdapter } from 'better-auth/adapters/prisma'
import { admin, customSession } from 'better-auth/plugins'
import { prisma } from './db'
import { ac, user, admin as adminRole } from './auth/permissions'
import { sendEmail } from './email'

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: 'postgresql',
  }),
  
  // Email/Password authentication
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
    autoSignInAfterVerification: true,
    sendResetPassword: async ({ user, url, token }, request) => {
      await sendEmail({
        to: user.email,
        subject: 'Reset your Apex Pro password',
        params: {
          greeting: 'Hello,',
          body_text: 'You requested a password reset for your Apex Pro account. Please click the button below to set a new password:',
          action_url: url,
          action_text: 'Reset Password',
          footer_text: "If you didn't request a password reset, please ignore this email.",
        },
      })
    },
  },
  
  // Social providers
  socialProviders: {
    github: {
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    },
  },
  
  // Email verification
  emailVerification: {
    sendOnSignUp: true,
    sendVerificationEmail: async ({ user, url, token }, request) => {
      await sendEmail({
        to: user.email,
        subject: 'Verify your Apex Pro email address',
        params: {
          greeting: 'Hello,',
          body_text: 'Thanks for signing up for Apex Pro! Please click the button below to verify your email address:',
          action_url: url,
          action_text: 'Verify Email',
          footer_text: "If you didn't sign up for Apex Pro, please ignore this email.",
        },
      })
    },
    autoSignInAfterVerification: true,
    onVerificationError: ({ request, response }) => {
      return {
        redirect: {
          url: '/verification-error',
        },
      }
    },
  },
  
  // Plugins for admin functionality and custom sessions
  plugins: [
    admin({
      ac,
      roles: {
        user,
        admin: adminRole
      },
      defaultRole: 'user'
    }),
    customSession(async (sessionData) => {
      const { user, session } = sessionData
      
      // Fetch the account for the user to get provider information
      const account = await prisma.account.findFirst({
        where: { userId: user.id },
      })

      // Return modified session data with provider information
      return {
        ...session,
        user: {
          ...user,
          providerId: account?.providerId || null,
        },
      }
    }),
  ],
})
```

## 3. Role-Based Access Control (RBAC)

We implemented a comprehensive permission system in `lib/auth/permissions.ts`:

```typescript
// lib/auth/permissions.ts
import { createAccessControl } from 'better-auth/plugins/access'
import { defaultStatements, adminAc } from 'better-auth/plugins/admin/access'

// Define our custom statements for questionnaires and responses
export const statement = {
  ...defaultStatements,
  questionnaire: [
    'create',
    'read',
    'update',
    'delete',
    'list',
    'share',
    'view-responses'
  ],
  'questionnaire-response': [
    'create',
    'read',
    'update',
    'delete',
    'list',
    'generate-sample-responses'
  ]
} as const

// Create the access control instance
const ac = createAccessControl(statement)

// Define roles with their permissions
export const user = ac.newRole({
  questionnaire: ['create', 'read', 'update', 'delete', 'list', 'share'],
  'questionnaire-response': ['create', 'read', 'list']
})

export const admin = ac.newRole({
  ...adminAc.statements,
  questionnaire: ['create', 'read', 'update', 'delete', 'list', 'share'],
  'questionnaire-response': ['create', 'read', 'update', 'delete', 'list', 'generate-sample-responses']
})

export { ac }
```

## 4. Client-Side Authentication

The client-side authentication is handled in `lib/auth-client.ts`:

```typescript
// lib/auth-client.ts
import { createAuthClient } from 'better-auth/vue'
import { adminClient } from 'better-auth/client/plugins'
import { ac, user, admin as adminRole } from './auth/permissions'

const baseURL = process.env.BETTER_AUTH_URL

export const authClient = createAuthClient({
  baseURL: baseURL,
  plugins: [
    adminClient({
      ac,
      roles: {
        user,
        admin: adminRole
      }
    })
  ],
})

export const {
  signIn,
  signOut,
  signUp,
  useSession,
  getSession,
  sendVerificationEmail,
} = authClient
```

## 5. Nuxt Plugin for Authentication

We created a Nuxt plugin to handle authentication state management:

```typescript
// app/plugins/auth.ts
import { authClient } from "@@/lib/auth-client"
import { useUserStore } from "~/stores/user"

export default defineNuxtPlugin({
  name: "auth",
  async setup() {
    const userStore = useUserStore()

    try {
      const sessionData = await authClient.getSession()

      if (sessionData?.data?.user) {
        userStore.setUser(sessionData.data.user)
        await userStore.fetchUserPermissions()
      }
    } catch (error) {
      console.log("getSession error:", error)
    }

    const { data: session } = await authClient.useSession(useFetch)

    watch(
      () => session.value?.user,
      async (newUser) => {
        userStore.setUser(newUser)
        if (newUser) {
          await userStore.fetchUserPermissions()
        } else {
          userStore.clearUserData()
        }
      },
      { immediate: true },
    )
  },
})
```

## 6. User Store with Pinia

Our user store manages authentication state and permissions:

```typescript
// app/stores/user.ts
import { defineStore } from 'pinia'

interface UserPermissions {
  [key: string]: boolean
}

interface PermissionsResponse {
  permissions: UserPermissions
  role: string
}

export const useUserStore = defineStore('user', () => {
  const permissions = ref<UserPermissions>({})
  const role = ref<string | null>(null)
  const isLoading = ref(false)
  const currentUser = ref<any | null>(null)
  const hasFetchedPermissions = ref(false)

  const hasPermission = (subject: string, action: string): boolean => {
    return permissions.value[`${subject}.${action}`] ?? false
  }

  const isAdmin = computed(() => role.value === 'admin')

  const userInitials = computed(() => {
    const user = currentUser.value
    if (!user) return null
    
    const name = user.name || user.email || ''
    if (!name) return ''
    
    const parts = name.split(' ')
    if (parts.length === 1) {
      return parts[0].charAt(0).toUpperCase()
    } else if (parts.length > 1) {
      return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase()
    }
    return ''
  })

  const loggedInUsingEmail = computed(() => {
    const user = currentUser.value
    if (!user || typeof (user as any).providerId === 'undefined') return false
    return (user as any).providerId === 'credential'
  })

  async function fetchUserPermissions() {
    if (!currentUser.value || hasFetchedPermissions.value) {
      return
    }

    isLoading.value = true
    try {
      const data = await $fetch<PermissionsResponse>('/api/auth/permissions')
      if (data) {
        permissions.value = data.permissions
        role.value = data.role
        hasFetchedPermissions.value = true
      } else {
        clearUserData()
      }
    } catch (error) {
      console.error('Error in fetchUserPermissions:', error)
      clearUserData()
    } finally {
      isLoading.value = false
    }
  }

  function clearUserData() {
    permissions.value = {}
    role.value = null
    currentUser.value = null
    hasFetchedPermissions.value = false
  }

  function setUser(user: any | null) {
    if (user) {
      if (!currentUser.value || currentUser.value.id !== user.id) {
        permissions.value = {}
        role.value = null
        hasFetchedPermissions.value = false
      }
      currentUser.value = user
    } else {
      clearUserData()
    }
  }

  const isAuthenticated = computed(() => {
    return currentUser.value !== null
  })

  return {
    permissions,
    role,
    isAuthenticated,
    isLoading,
    currentUser,
    isAdmin,
    userInitials,
    loggedInUsingEmail,
    fetchUserPermissions,
    hasPermission,
    clearUserData,
    setUser,
  }
})
```

## 7. Global Authentication Middleware

We implemented global middleware to protect routes:

```typescript
// app/middleware/auth.global.ts
import { authClient } from '@@/lib/auth-client'

export default defineNuxtRouteMiddleware(async (to) => {
  // Define public routes that don't require authentication
  const publicRoutes = ['/login', '/signup', '/blog', '/contact']
  const isPublicRoute = publicRoutes.find(route => to.path.includes(route))
  
  if (isPublicRoute || to.meta?.public === true || to.path === "/" || to.path === "/en" || to.path === "/nl") {
    return
  }
  
  try {
    const { data: session } = await authClient.useSession(useFetch)

    if (!session.value) {
      const redirectPath = `/login?redirect=${encodeURIComponent(to.fullPath)}`
      return navigateTo(redirectPath, {
        external: false,
        replace: true,
      })
    }
  } catch (error) {
    console.error('Auth middleware error:', error)
    return navigateTo('/login', {
      external: false,
      replace: true,
    })
  }
})
```

## 8. API Route Handler

The API route handler connects Better Auth to our Nuxt application:

```typescript
// server/api/auth/[...].ts
import { auth } from '@@/lib/auth'
import { toWebRequest } from 'h3'

export default defineEventHandler(async (event) => {
  return auth.handler(toWebRequest(event))
})
```

## 9. Permissions API Endpoint

We created an endpoint to fetch user permissions:

```typescript
// server/api/auth/permissions.get.ts
import { defineEventHandler, createError } from 'h3'
import { auth } from '@@/lib/auth'
import { statement, user, admin } from '../../../lib/auth/permissions'
import { prisma } from '@@/lib/db'

export default defineEventHandler(async (event) => {
  // Get authenticated user
  const session = await auth.api.getSession({ headers: event.headers })
  if (!session?.user) {
    throw createError({ statusCode: 401, statusMessage: 'Unauthorized' })
  }

  // Get user's role from the database
  const dbUser = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true }
  })

  const userRole = dbUser?.role || 'user'
  const roleDefinition = userRole === 'admin' ? admin : user

  // Get all permissions for the user
  const permissions: Record<string, boolean> = {}

  // Check each subject and permission combination
  for (const [subject, actions] of Object.entries(statement)) {
    if (Array.isArray(actions)) {
      for (const action of actions) {
        const rolePermissions = roleDefinition.statements[subject as 'questionnaire' | 'questionnaire-response'] || []
        permissions[`${subject}.${action}`] = rolePermissions.includes(action)
      }
    }
  }

  return {
    permissions,
    role: userRole
  }
})
```

## 10. Usage in Components

Here's how you can use the authentication system in your components:

```vue
<template>
  <div>
    <div v-if="userStore.isAuthenticated">
      <h1>Welcome, {{ userStore.currentUser?.name || userStore.currentUser?.email }}!</h1>
      
      <div v-if="userStore.isAdmin">
        <p>You have admin privileges</p>
      </div>
      
      <div v-if="userStore.hasPermission('questionnaire', 'create')">
        <button>Create Questionnaire</button>
      </div>
      
      <button @click="handleSignOut">Sign Out</button>
    </div>
    
    <div v-else>
      <NuxtLink to="/login">Sign In</NuxtLink>
    </div>
  </div>
</template>

<script setup>
const userStore = useUserStore()
const { signOut } = authClient

const handleSignOut = async () => {
  await signOut()
}
</script>
```

## Key Benefits of This Setup

1. **Type Safety**: Full TypeScript support throughout the authentication flow
2. **Role-Based Access Control**: Granular permissions system with role definitions
3. **Social Login**: Easy integration with GitHub and other providers
4. **Email Verification**: Built-in email verification with custom templates
5. **Session Management**: Automatic session handling with custom session data
6. **Global Middleware**: Automatic route protection
7. **Reactive State**: Pinia store with reactive authentication state
8. **Permission Checking**: Easy permission checking in components

## Environment Variables

Make sure to set up these environment variables:

```env
DATABASE_URL="postgresql://..."
BETTER_AUTH_URL="http://localhost:3000"
BETTER_AUTH_SECRET="your-secret-key"
GITHUB_CLIENT_ID="your-github-client-id"
GITHUB_CLIENT_SECRET="your-github-client-secret"
```

## Conclusion

This authentication setup provides a robust, scalable solution for handling user authentication in a Nuxt 3 application. The combination of Better Auth's powerful features with our custom permission system and reactive state management creates a seamless user experience while maintaining security and type safety throughout the application.

The modular approach allows for easy extension and customization, making it suitable for applications of any size while providing enterprise-level security features out of the box.
