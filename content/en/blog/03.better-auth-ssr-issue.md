---
title: "Better-Auth SSR Issue: When Server-Side Rendering Doesn't Know You're Logged In"
description: "A deep dive into the common SSR authentication issue with better-auth in Nuxt applications, where the server doesn't recognize authenticated users during initial page load."
image:
  src: /images/blog/auth/1.png
authors:
  - name: Marcel Posdijk
    to: https://x.com/marcelposdijk
    avatar:
      src: https://avatars.githubusercontent.com/u/20837346?v=4
date: 2025-10-25
badge:
  label: Authentication
---

## The Problem: Flash of Unauthenticated Content

You've built a beautiful customer portal with better-auth and Nuxt. Everything works perfectly when users navigate between pages, but there's one annoying issue: when users first visit your site, they see a brief flash of the "Login" button before it changes to "Dashboard" - even when they're already logged in.

This is a classic Server-Side Rendering (SSR) authentication issue. The server doesn't know about the user's session during the initial page render, so it renders the unauthenticated state. Then, when the JavaScript loads on the client, it detects the session and updates the UI.

![error message screen](/images/blog/auth/1.png){.rounded-lg height="600" width="1000"}

## Why This Happens

The issue occurs because of how SSR works with authentication:

1. **Server-side rendering**: The server renders the page without access to browser cookies or session data
2. **Client-side hydration**: The browser loads the JavaScript and detects the session
3. **UI update**: The interface updates to show the authenticated state

This creates a jarring user experience where users see:
- "Log in" button → "Dashboard" button (flash of incorrect content)
- Instead of: "Dashboard" button (correct from the start)

## The Root Cause

In better-auth with Nuxt, the problem typically stems from:

### 1. Plugin Execution Timing
```typescript
// ❌ This skips server-side session initialization
export default defineNuxtPlugin({
  async setup() {
    if (import.meta.server) {
      return // Skip server-side execution
    }
    // Only runs on client
  }
})
```

### 2. Plugin vs Page Component Context
```typescript
// ✅ This works in page components (according to better-auth docs)
const { data: session } = await authClient.useSession(useFetch)
console.log(session.value?.user) // user object

// ❌ But this doesn't work in plugins on server-side
// The session is undefined in plugin context during SSR
```

### 3. Plugin Context Limitations
The issue is that `useSession(useFetch)` works perfectly in page components but has limitations in plugin context during SSR. The plugin runs before the page components, and the session data isn't available yet.

## The Solution

The issue is that `useSession(useFetch)` works perfectly in page components (as documented) but has limitations in plugin context during SSR. Here's how to fix it:

### 1. Use getSession() for Server-Side Detection

```typescript
// app/plugins/auth.ts
export default defineNuxtPlugin({
  name: 'auth',
  async setup() {
    const userStore = useUserStore()

    // Use getSession() for server-side session detection
    // This works in plugin context during SSR
    try {
      const sessionData = await authClient.getSession()
      
      if (sessionData?.data?.user) {
        userStore.setUser(sessionData.data.user)
        // Only fetch permissions on client side
        if (!import.meta.server) {
          await userStore.fetchUserPermissions()
        }
      }
    } catch (error) {
      console.log('getSession error:', error)
    }

    // Use useSession(useFetch) for client-side reactive updates
    // This works perfectly on client-side
    if (!import.meta.server) {
      const { data: session } = await authClient.useSession(useFetch)
      
      watch(() => session.value?.user, async (newUser) => {
        userStore.setUser(newUser)
        if (newUser) {
          await userStore.fetchUserPermissions()
        } else {
          userStore.clearUserData()
        }
      }, { immediate: true })
    }
  }
})
```

### 2. Key Changes Made

- **Server-side session check**: Use `authClient.getSession()` for server-side detection (works in plugin context)
- **Client-side reactive updates**: Use `useSession(useFetch)` for client-side reactive updates (works perfectly on client)
- **Conditional permissions**: Only fetch permissions on client to avoid SSR issues
- **Hybrid approach**: Different methods for server vs client contexts

### 3. How It Works Now

1. **Server**: Plugin runs, gets session, sets user in store
2. **SSR**: Home page renders with correct user state (Dashboard button)
3. **Client**: Plugin runs again, sets up reactive watcher
4. **Hydration**: No flash because server and client have the same state

## Testing the Fix

To verify the fix works:

1. **Log in** to your application
2. **Refresh the page** - you should see the Dashboard button immediately
3. **No flash** of login button before dashboard button
4. **Console logs** should show session data on both server and client

## Common Pitfalls

### 1. Skipping Server-Side Execution
```typescript
// ❌ Don't do this
if (import.meta.server) {
  return // This prevents SSR from working
}
```

### 2. Plugin vs Page Component Context
```typescript
// ✅ This works in page components (as per better-auth docs)
const { data: session } = await authClient.useSession(useFetch)
session.value?.user

// ❌ But this doesn't work in plugins during SSR
// The session is undefined in plugin context
```

### 3. Fetching Permissions on Server
```typescript
// ❌ Can cause SSR issues
await userStore.fetchUserPermissions() // on server

// ✅ Only on client
if (!import.meta.server) {
  await userStore.fetchUserPermissions()
}
```

## The Result

With this fix, your users will experience:

- ✅ **Immediate correct state**: Dashboard button shows right away
- ✅ **No flash of incorrect content**: Smooth user experience
- ✅ **Proper SSR**: Server knows about authentication state
- ✅ **Reactive updates**: Client-side changes still work

## Conclusion

SSR authentication issues are common but solvable. The key is ensuring that both server and client have access to the same session data during the initial render. With better-auth and Nuxt, this means:

1. Running session checks on both server and client
2. Using the correct session data access patterns
3. Being careful about what operations run on the server vs client

The result is a seamless authentication experience that works perfectly with SSR while maintaining all the reactive benefits of client-side authentication.
