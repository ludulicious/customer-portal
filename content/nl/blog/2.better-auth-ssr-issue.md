---
title: "Better-Auth SSR Probleem: Wanneer Server-Side Rendering Niet Weet Dat Je Ingelogd Bent"
description: "Een diepgaande blik op het veelvoorkomende SSR authenticatie probleem met better-auth in Nuxt applicaties, waarbij de server ingelogde gebruikers niet herkent tijdens de eerste pagina load."
image:
  src: https://picsum.photos/id/42/640/360
authors:
  - name: Marcel Posdijk
    to: https://x.com/marcelposdijk
    avatar:
      src: https://avatars.githubusercontent.com/u/20837346?v=4
date: 2025-01-24
badge:
  label: Authenticatie
---

## Het Probleem: Flash van Niet-Authenticated Content

Je hebt een prachtige klantenportal gebouwd met better-auth en Nuxt. Alles werkt perfect wanneer gebruikers tussen pagina's navigeren, maar er is één vervelend probleem: wanneer gebruikers je site voor het eerst bezoeken, zien ze een korte flits van de "Inloggen" knop voordat deze verandert naar "Dashboard" - zelfs wanneer ze al ingelogd zijn.

Dit is een klassiek Server-Side Rendering (SSR) authenticatie probleem. De server weet niets over de sessie van de gebruiker tijdens de eerste pagina render, dus rendert het de niet-geauthenticeerde staat. Dan, wanneer de JavaScript laadt op de client, detecteert het de sessie en werkt de UI bij.

![Authenticatie Flow](https://picsum.photos/id/42/1000/600){.rounded-lg height="600" width="1000"}

## Waarom Dit Gebeurt

Het probleem ontstaat door hoe SSR werkt met authenticatie:

1. **Server-side rendering**: De server rendert de pagina zonder toegang tot browser cookies of sessie data
2. **Client-side hydratatie**: De browser laadt de JavaScript en detecteert de sessie
3. **UI update**: De interface werkt bij om de geauthenticeerde staat te tonen

Dit creëert een schokkende gebruikerservaring waar gebruikers zien:
- "Inloggen" knop → "Dashboard" knop (flits van incorrecte content)
- In plaats van: "Dashboard" knop (correct vanaf het begin)

## De Oorzaak

In better-auth met Nuxt komt het probleem typisch voort uit:

### 1. Plugin Uitvoering Timing
```typescript
// ❌ Dit slaat server-side sessie initialisatie over
export default defineNuxtPlugin({
  async setup() {
    if (import.meta.server) {
      return // Sla server-side uitvoering over
    }
    // Loopt alleen op client
  }
})
```

### 2. Plugin vs Page Component Context
```typescript
// ✅ Dit werkt in page components (volgens better-auth docs)
const { data: session } = await authClient.useSession(useFetch)
console.log(session.value?.user) // user object

// ❌ Maar dit werkt niet in plugins op server-side
// De sessie is undefined in plugin context tijdens SSR
```

### 3. Plugin Context Beperkingen
Het probleem is dat `useSession(useFetch)` perfect werkt in page components maar beperkingen heeft in plugin context tijdens SSR. De plugin loopt voor de page components, en de sessie data is nog niet beschikbaar.

## De Oplossing

Het probleem is dat `useSession(useFetch)` perfect werkt in page components (zoals gedocumenteerd) maar beperkingen heeft in plugin context tijdens SSR. Hier is hoe je het oplost:

### 1. Gebruik getSession() voor Server-Side Detectie

```typescript
// app/plugins/auth.ts
export default defineNuxtPlugin({
  name: 'auth',
  async setup() {
    const userStore = useUserStore()

    // Gebruik getSession() voor server-side sessie detectie
    // Dit werkt in plugin context tijdens SSR
    try {
      const sessionData = await authClient.getSession()
      
      if (sessionData?.data?.user) {
        userStore.setUser(sessionData.data.user)
        // Haal alleen permissions op client side op
        if (!import.meta.server) {
          await userStore.fetchUserPermissions()
        }
      }
    } catch (error) {
      console.log('getSession error:', error)
    }

    // Gebruik useSession(useFetch) voor client-side reactieve updates
    // Dit werkt perfect op client-side
    if (!import.meta.server) {
      const { data: session } = await authClient.useSession(useFetch)
      
      watch(() => session.value?.user, async (newUser) => {
        userStore.setUser(newUser)
        if (newUser) {
          await userStore.fetchUserPermissions()
        } else {
          userStore.clearUserData()
        }
      }, { immediate: true })
    }
  }
})
```

### 2. Belangrijkste Wijzigingen

- **Server-side sessie check**: Gebruik `authClient.getSession()` voor server-side detectie (werkt in plugin context)
- **Client-side reactieve updates**: Gebruik `useSession(useFetch)` voor client-side reactieve updates (werkt perfect op client)
- **Conditionele permissions**: Haal alleen permissions op client op om SSR problemen te vermijden
- **Hybride aanpak**: Verschillende methoden voor server vs client contexts

### 3. Hoe Het Nu Werkt

1. **Server**: Plugin loopt, krijgt sessie, zet gebruiker in store
2. **SSR**: Home pagina rendert met correcte gebruiker staat (Dashboard knop)
3. **Client**: Plugin loopt opnieuw, zet reactieve watcher op
4. **Hydratatie**: Geen flits omdat server en client dezelfde staat hebben

## De Fix Testen

Om te verifiëren dat de fix werkt:

1. **Log in** op je applicatie
2. **Ververs de pagina** - je zou de Dashboard knop direct moeten zien
3. **Geen flits** van login knop voor dashboard knop
4. **Console logs** zouden sessie data moeten tonen op zowel server als client

## Veelgemaakte Fouten

### 1. Server-Side Uitvoering Overslaan
```typescript
// ❌ Doe dit niet
if (import.meta.server) {
  return // Dit voorkomt dat SSR werkt
}
```

### 2. Plugin vs Page Component Context
```typescript
// ✅ Dit werkt in page components (volgens better-auth docs)
const { data: session } = await authClient.useSession(useFetch)
session.value?.user

// ❌ Maar dit werkt niet in plugins tijdens SSR
// De sessie is undefined in plugin context
```

### 3. Permissions Ophalen op Server
```typescript
// ❌ Kan SSR problemen veroorzaken
await userStore.fetchUserPermissions() // op server

// ✅ Alleen op client
if (!import.meta.server) {
  await userStore.fetchUserPermissions()
}
```

## Het Resultaat

Met deze fix zullen je gebruikers ervaren:

- ✅ **Onmiddellijke correcte staat**: Dashboard knop toont direct
- ✅ **Geen flits van incorrecte content**: Soepele gebruikerservaring
- ✅ **Correcte SSR**: Server weet over authenticatie staat
- ✅ **Reactieve updates**: Client-side wijzigingen werken nog steeds

## Conclusie

SSR authenticatie problemen zijn veelvoorkomend maar oplosbaar. De sleutel is ervoor zorgen dat zowel server als client toegang hebben tot dezelfde sessie data tijdens de eerste render. Met better-auth en Nuxt betekent dit:

1. Sessie checks uitvoeren op zowel server als client
2. De correcte sessie data toegang patronen gebruiken
3. Voorzichtig zijn over welke operaties op server vs client lopen

Het resultaat is een naadloze authenticatie ervaring die perfect werkt met SSR terwijl alle reactieve voordelen van client-side authenticatie behouden blijven.
